{"ast":null,"code":"var max = require('lodash/max');\n\nvar compact = require('lodash/compact');\n\nvar times = require('lodash/times');\n\nvar trimStart = require('lodash/trimStart');\n\nvar padEnd = require('lodash/padEnd');\n\nvar he = require('he');\n\nvar helper = require('./helper');\n\nfunction formatText(elem, options) {\n  var text = elem.data || \"\";\n  text = he.decode(text, options.decodeOptions);\n\n  if (options.isInPre) {\n    return text;\n  } else {\n    return helper.wordwrap(elem.trimLeadingSpace ? trimStart(text) : text, options);\n  }\n}\n\nfunction formatImage(elem, options) {\n  if (options.ignoreImage) {\n    return '';\n  }\n\n  var result = '',\n      attribs = elem.attribs || {};\n\n  if (attribs.alt) {\n    result += he.decode(attribs.alt, options.decodeOptions);\n\n    if (attribs.src) {\n      result += ' ';\n    }\n  }\n\n  if (attribs.src) {\n    result += '[' + attribs.src + ']';\n  }\n\n  return result;\n}\n\nfunction formatLineBreak(elem, fn, options) {\n  return '\\n' + fn(elem.children, options);\n}\n\nfunction formatParagraph(elem, fn, options) {\n  var paragraph = fn(elem.children, options);\n\n  if (options.singleNewLineParagraphs) {\n    return paragraph + '\\n';\n  } else {\n    return paragraph + '\\n\\n';\n  }\n}\n\nfunction formatHeading(elem, fn, options) {\n  var heading = fn(elem.children, options);\n\n  if (options.uppercaseHeadings) {\n    heading = heading.toUpperCase();\n  }\n\n  return heading + '\\n';\n} // If we have both href and anchor text, format it in a useful manner:\n// - \"anchor text [href]\"\n// Otherwise if we have only anchor text or an href, we return the part we have:\n// - \"anchor text\" or\n// - \"href\"\n\n\nfunction formatAnchor(elem, fn, options) {\n  var href = ''; // Always get the anchor text\n\n  var storedCharCount = options.lineCharCount;\n  var text = fn(elem.children || [], options);\n\n  if (!text) {\n    text = '';\n  }\n\n  var result = elem.trimLeadingSpace ? trimStart(text) : text;\n\n  if (!options.ignoreHref) {\n    // Get the href, if present\n    if (elem.attribs && elem.attribs.href) {\n      href = elem.attribs.href.replace(/^mailto:/, '');\n    }\n\n    if (href) {\n      if (!options.noAnchorUrl || options.noAnchorUrl && href[0] !== '#') {\n        if (options.linkHrefBaseUrl && href.indexOf('/') === 0) {\n          href = options.linkHrefBaseUrl + href;\n        }\n\n        if (!options.hideLinkHrefIfSameAsText || href !== helper.replaceAll(result, '\\n', '')) {\n          if (!options.noLinkBrackets) {\n            result += ' [' + href + ']';\n          } else {\n            result += ' ' + href;\n          }\n        }\n      }\n    }\n  }\n\n  options.lineCharCount = storedCharCount;\n  return formatText({\n    data: result || href,\n    trimLeadingSpace: elem.trimLeadingSpace\n  }, options);\n}\n\nfunction formatHorizontalLine(elem, fn, options) {\n  return '\\n' + '-'.repeat(options.wordwrap) + '\\n\\n';\n}\n\nfunction formatListItem(prefix, elem, fn, options) {\n  options = Object.assign({}, options); // Reduce the wordwrap for sub elements.\n\n  if (options.wordwrap) {\n    options.wordwrap -= prefix.length;\n  } // Process sub elements.\n\n\n  var text = fn(elem.children, options); // Replace all line breaks with line break + prefix spacing.\n\n  text = text.replace(/\\n/g, '\\n' + ' '.repeat(prefix.length)); // Add first prefix and line break at the end.\n\n  return prefix + text + '\\n';\n}\n\nvar whiteSpaceRegex = /^\\s*$/;\n\nfunction formatUnorderedList(elem, fn, options) {\n  var result = '';\n  var prefix = options.unorderedListItemPrefix;\n  var nonWhiteSpaceChildren = (elem.children || []).filter(function (child) {\n    return child.type !== 'text' || !whiteSpaceRegex.test(child.data);\n  });\n  nonWhiteSpaceChildren.forEach(function (elem) {\n    result += formatListItem(prefix, elem, fn, options);\n  });\n  return result + '\\n';\n}\n\nfunction formatOrderedList(elem, fn, options) {\n  var result = '';\n  var nonWhiteSpaceChildren = (elem.children || []).filter(function (child) {\n    return child.type !== 'text' || !whiteSpaceRegex.test(child.data);\n  }); // Return different functions for different OL types\n\n  var typeFunction = function () {\n    // Determine type\n    var olType = elem.attribs.type || '1'; // TODO Imeplement the other valid types\n    //   Fallback to type '1' function for other valid types\n\n    switch (olType) {\n      case 'a':\n        return function (start, i) {\n          return String.fromCharCode(i + start + 97);\n        };\n\n      case 'A':\n        return function (start, i) {\n          return String.fromCharCode(i + start + 65);\n        };\n\n      case '1':\n      default:\n        return function (start, i) {\n          return i + 1 + start;\n        };\n    }\n  }(); // Make sure there are list items present\n\n\n  if (nonWhiteSpaceChildren.length) {\n    // Calculate initial start from ol attribute\n    var start = Number(elem.attribs.start || '1') - 1; // Calculate the maximum length to i.\n\n    var maxLength = (nonWhiteSpaceChildren.length + start).toString().length;\n    nonWhiteSpaceChildren.forEach(function (elem, i) {\n      // Use different function depending on type\n      var index = typeFunction(start, i); // Calculate the needed spacing for nice indentation.\n\n      var spacing = maxLength - index.toString().length;\n      var prefix = ' ' + index + '. ' + ' '.repeat(spacing);\n      result += formatListItem(prefix, elem, fn, options);\n    });\n  }\n\n  return result + '\\n';\n}\n\nfunction tableToString(table) {\n  // Determine space width per column\n  // Convert all rows to lengths\n  var widths = table.map(function (row) {\n    return row.map(function (col) {\n      return col.length;\n    });\n  }); // Invert rows with colums\n\n  widths = helper.arrayZip(widths); // Determine the max values for each column\n\n  widths = widths.map(function (col) {\n    return max(col);\n  }); // Build the table\n\n  var text = '';\n  table.forEach(function (row) {\n    var i = 0;\n    row.forEach(function (col) {\n      text += padEnd(col.trim(), widths[i++], ' ') + '   ';\n    });\n    text += '\\n';\n  });\n  return text + '\\n';\n}\n\nfunction formatTable(elem, fn, options) {\n  var table = [];\n  elem.children.forEach(tryParseRows);\n  return tableToString(table);\n\n  function tryParseRows(elem) {\n    if (elem.type !== 'tag') {\n      return;\n    }\n\n    switch (elem.name.toLowerCase()) {\n      case \"thead\":\n      case \"tbody\":\n      case \"tfoot\":\n      case \"center\":\n        elem.children.forEach(tryParseRows);\n        return;\n\n      case 'tr':\n        var rows = [];\n        elem.children.forEach(function (elem) {\n          var tokens, count;\n\n          if (elem.type === 'tag') {\n            switch (elem.name.toLowerCase()) {\n              case 'th':\n                tokens = formatHeading(elem, fn, options).split('\\n');\n                rows.push(compact(tokens));\n                break;\n\n              case 'td':\n                tokens = fn(elem.children, options).split('\\n');\n                rows.push(compact(tokens)); // Fill colspans with empty values\n\n                if (elem.attribs && elem.attribs.colspan) {\n                  count = elem.attribs.colspan - 1 || 0;\n                  times(count, function () {\n                    rows.push(['']);\n                  });\n                }\n\n                break;\n            }\n          }\n        });\n        rows = helper.arrayZip(rows);\n        rows.forEach(function (row) {\n          row = row.map(function (col) {\n            return col || '';\n          });\n          table.push(row);\n        });\n        break;\n    }\n  }\n}\n\nfunction formatBlockquote(elem, fn, options) {\n  return '> ' + fn(elem.children, options) + '\\n';\n}\n\nexports.text = formatText;\nexports.image = formatImage;\nexports.lineBreak = formatLineBreak;\nexports.paragraph = formatParagraph;\nexports.anchor = formatAnchor;\nexports.heading = formatHeading;\nexports.table = formatTable;\nexports.orderedList = formatOrderedList;\nexports.unorderedList = formatUnorderedList;\nexports.listItem = formatListItem;\nexports.horizontalLine = formatHorizontalLine;\nexports.blockquote = formatBlockquote;","map":null,"metadata":{},"sourceType":"script"}